<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Flappy Mini · buildyourside</title>
<style>
  html,body{margin:0;height:100%;background:#0d1117;color:#e6edf3;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  .wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:10px}
  #c{background:#121826;border:2px solid #222a3a;border-radius:12px;touch-action:manipulation;}
  .hud{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:center}
  .btn{cursor:pointer;border:1px solid #2a3245;border-radius:10px;padding:6px 10px;background:#141a26}
  .btn:active{transform:translateY(1px)}
  .score{font-weight:700}
  a{color:#8ab4f8;text-decoration:none}
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <span class="score">Score: <span id="score">0</span></span>
    <span>Best: <span id="best">0</span></span>
    <button id="start" class="btn">▶︎ Start</button>
    <button id="pause" class="btn">⏸ Pause</button>
    <button id="restart" class="btn">↺ Restart</button>
  </div>
  <canvas id="c" width="420" height="680" aria-label="Flappy Mini"></canvas>
  <div style="opacity:.7;font-size:14px">
    点击 / 触摸 / 空格键 跳跃 · P 暂停 · 纯前端 · 无资源文件
  </div>
  <div style="opacity:.6;font-size:12px">
    © buildyourside.com · <a href="/">返回首页</a>
  </div>
</div>

<script>
(function(){
  const cvs = document.getElementById('c');
  const ctx = cvs.getContext('2d');
  const $score = document.getElementById('score');
  const $best = document.getElementById('best');
  const $start = document.getElementById('start');
  const $pause = document.getElementById('pause');
  const $restart = document.getElementById('restart');
  const BEST_KEY = 'flappy_best_v1';

  // 响应式：小屏自动缩放到窗口宽度
  function fitCanvas(){
    const maxW = Math.min(480, window.innerWidth - 20);
    const scale = maxW / cvs.width;
    cvs.style.width = (cvs.width * scale) + 'px';
    cvs.style.height= (cvs.height* scale) + 'px';
  }
  window.addEventListener('resize', fitCanvas); fitCanvas();

  // 游戏参数（尽量小内存、少对象复用）
  const W = cvs.width, H = cvs.height;
  const GRAV = 1500;       // 重力 px/s^2
  const JUMP_V = -420;     // 跳跃初速度
  const BIRD_X = W*0.28;
  const PIPE_GAP_MIN = 150, PIPE_GAP_MAX = 190;
  const PIPE_W = 70;
  const PIPE_SPEED = 160;  // px/s
  const PIPE_INTERVAL = 1450; // ms

  // 状态
  let birdY, birdV, score, best, running=false, paused=false, gameOver=false;
  let lastTS=0, accInterval=0;
  const pipes = []; // {x, topH, gap}
  // 为减少垃圾回收，使用少量颜色与简易绘制
  const skyGrad = ctx.createLinearGradient(0,0,0,H);
  skyGrad.addColorStop(0,'#0b1224');
  skyGrad.addColorStop(1,'#0f172a');

  function reset(){
    pipes.length = 0;
    birdY = H/2;
    birdV = 0;
    score = 0;
    gameOver = false;
    accInterval = 0;
    lastTS = 0;
    $score.textContent = score;
    best = parseInt(localStorage.getItem(BEST_KEY)||'0',10);
    $best.textContent = best;
  }

  function spawnPipe(){
    const gap = rand(PIPE_GAP_MIN, PIPE_GAP_MAX);
    const margin = 40;
    const topH = rand(margin, H - margin - gap);
    pipes.push({ x: W + PIPE_W, topH, gap, passed:false });
  }

  function update(dt){
    if (paused || gameOver) return;

    // 鸟物理
    birdV += GRAV * dt;
    birdY += birdV * dt;

    // 管道生成&移动
    accInterval += dt*1000;
    if (accInterval >= PIPE_INTERVAL){
      accInterval -= PIPE_INTERVAL;
      spawnPipe();
    }
    for (let i=0;i<pipes.length;i++){
      const p = pipes[i];
      p.x -= PIPE_SPEED * dt;
      // 计分：鸟中心越过管道中心一次
      if (!p.passed && p.x + PIPE_W < BIRD_X){
        p.passed = true;
        score++;
        $score.textContent = score;
      }
    }
    // 清理离开屏幕的管道（最多保留6个以内）
    while (pipes.length && pipes[0].x + PIPE_W < -10) pipes.shift();
    if (pipes.length > 6) pipes.shift();

    // 碰撞检测
    if (birdY < 0 || birdY > H){
      endGame();
      return;
    }
    for (let i=0;i<pipes.length;i++){
      const p = pipes[i];
      if (AABB(BIRD_X-16, birdY-16, 32,32, p.x,0, PIPE_W, p.topH) ||
          AABB(BIRD_X-16, birdY-16, 32,32, p.x, p.topH + p.gap, PIPE_W, H)){
        endGame();
        return;
      }
    }
  }

  function draw(){
    // 背景
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0,0,W,H);

    // 星点（程序绘制，极小成本）
    ctx.globalAlpha = 0.08;
    for (let i=0;i<60;i++){
      const x = (i*73)%W, y=(i*127)%H;
      ctx.fillStyle = '#b6c5ff';
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    // 地面
    ctx.fillStyle = '#0b132b';
    ctx.fillRect(0, H-40, W, 40);

    // 管道
    for (let i=0;i<pipes.length;i++){
      const p = pipes[i];
      // 上
      pipeRect(p.x, 0, PIPE_W, p.topH);
      // 下
      pipeRect(p.x, p.topH + p.gap, PIPE_W, H - (p.topH + p.gap));
    }

    // 鸟（用圆+眼睛，不用图片）
    drawBird(BIRD_X, birdY);

    // 文本
    if (!running && !gameOver){
      banner('点击 / 空格 开始', H*0.42);
    }
    if (paused){
      banner('已暂停 · 按 P 或 点击继续', H*0.42);
    }
    if (gameOver){
      banner('Game Over  ·  ↺ Restart', H*0.40);
      smallText(`Score ${score}  ·  Best ${best}`, H*0.40 + 40);
    }
  }

  function frame(ts){
    if (!running){ draw(); return; }
    if (!lastTS) lastTS = ts;
    const dt = Math.min(0.033, (ts - lastTS)/1000);
    lastTS = ts;
    update(dt);
    draw();
    requestAnimationFrame(frame);
  }

  // --- 绘制助手 ---
  function pipeRect(x,y,w,h){
    ctx.fillStyle = '#1f2937';
    ctx.fillRect(x,y,w,h);
    ctx.strokeStyle = '#2a364a';
    ctx.lineWidth = 3;
    ctx.strokeRect(x+0.5,y+0.5,w-1,h-1);
    // 边缘高光
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#9fb5ff';
    ctx.fillRect(x+4,y+4,w-8,6);
    ctx.globalAlpha = 1;
  }
  function drawBird(x,y){
    // 身体
    ctx.beginPath();
    ctx.arc(x, y, 16, 0, Math.PI*2);
    ctx.closePath();
    ctx.fillStyle = '#ffd166';
    ctx.fill();
    ctx.strokeStyle = '#e0a800';
    ctx.stroke();
    // 翅膀（轻微上下摆）
    const flap = Math.sin(perf())*4;
    ctx.beginPath();
    ctx.ellipse(x-6, y+flap, 10,6, 0, 0, Math.PI*2);
    ctx.fillStyle = '#f9c74f';
    ctx.fill();
    // 眼睛
    ctx.beginPath();
    ctx.arc(x+6, y-6, 4, 0, Math.PI*2);
    ctx.fillStyle = '#fff';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x+6, y-6, 2, 0, Math.PI*2);
    ctx.fillStyle = '#000';
    ctx.fill();
    // 嘴
    ctx.beginPath();
    ctx.moveTo(x+14, y-2);
    ctx.lineTo(x+22, y+1);
    ctx.lineTo(x+14, y+4);
    ctx.closePath();
    ctx.fillStyle = '#f77f00';
    ctx.fill();
  }
  function banner(text, y){
    ctx.font = 'bold 28px system-ui,Arial';
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    const w = ctx.measureText(text).width + 28;
    const x = (W - w)/2;
    ctx.fillRect(x, y-30, w, 48);
    ctx.fillStyle = '#e6edf3';
    ctx.fillText(text, (W - ctx.measureText(text).width)/2, y);
  }
  function smallText(text, y){
    ctx.font = '600 18px system-ui,Arial';
    ctx.fillStyle = '#cbd5e1';
    ctx.fillText(text, (W - ctx.measureText(text).width)/2, y);
  }
  function AABB(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }
  function rand(a,b){ return (a + Math.random()*(b-a))|0; }
  function perf(){ return (performance.now()/180); }

  // --- 控制 ---
  function jump(){
    if (!running){ start(); return; }
    if (gameOver){ reset(); return; }
    if (paused){ paused=false; return; }
    birdV = JUMP_V;
  }
  function start(){
    if (running) return;
    reset();
    running = true;
    paused = false;
    requestAnimationFrame(frame);
  }
  function endGame(){
    gameOver = true;
    running = false;
    if (score > best){
      best = score;
      localStorage.setItem(BEST_KEY, String(best));
      $best.textContent = best;
    }
  }
  function togglePause(){
    if (!running || gameOver) return;
    paused = !paused;
    if (!paused){
      lastTS = 0;
      requestAnimationFrame(frame);
    } else {
      draw();
    }
  }
  // 事件
  cvs.addEventListener('pointerdown', jump, {passive:true});
  window.addEventListener('keydown', (e)=>{
    if (e.code === 'Space') { e.preventDefault(); jump(); }
    if (e.key.toLowerCase() === 'p') togglePause();
    if (e.key.toLowerCase() === 'r') { reset(); running=false; draw(); }
  });
  $start.onclick = start;
  $pause.onclick = togglePause;
  $restart.onclick = ()=>{ reset(); running=false; draw(); };

  // 初始渲染
  reset(); draw();
})();
</script>
</body>
</html>
